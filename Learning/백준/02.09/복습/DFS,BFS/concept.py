# DFS와 BFS의 컨셉에 대해서 다시한번 복기해보자
# 일단 두 알고리즘은 Graph라는 자료구조 개념에서 시작한다.
# Graph는 지점과 각각의 지점을 연결하는 간선으로 이루어져 있다.
# 이렇게 서로 연결되어 있는 요소들 한 덩이을 연결요소라고 부른다.
# 이러한 형태의 자료구조는 인접행렬과 인접리스트를 토대로 표현할 수 있는데
# 인접행렬은 시간복잡도 측면에서, 인접리스트는 메모리 측면에서 각각 유리하다.
# 지금까지는 인접행렬만을 활용하여 문제를 풀어왔다.
# DFS와 BFS는 각각 우선적으로 탐색하는 범위에 차이가 있는데
# DFS는 깊이 우선 탐색으로써 지속적으로 다음 지점을 찾아가고
# BFS는 넓이 우선 탐색으로써 주변에 있는 같은 지점을 우선으로 찾아간다.
# 특히 BFS는 길찾기에서 주로 활용이 되는데 현재 지점에서 다음 단계로 넘어갈 수 있는 모든 경로를 탐색하고 한단계씩 진행하며 최종 종착지에 다다르기 위한 최단경로를 찾는 형식의 문제가 대표적이다.

# 예시를 하나 들어보자

import sys
input = sys.stdin.readline

N = int(input()) # 대부분의 N값이 1 <= N 으로 주어진다 

adj=[[0]* (N) for _ in range(N)]
# 이런식으로 먼저 인접행렬을 생성해준다.
# DFS 문제에서 주로 볼 수 있었다.
# adj[1][3] = 1 ### -> 2번째 행의 4번째 열에 1이 표시된다. 
# adj[3][5] = 1 ### -> 이는 인접행렬에서 보면 4번째 행의 6번째 열의 좌표를 찍기 때문에 Out of index가 난다.

#따라서 행렬의 좌표값을 받을때는 -1 을 해준다

for _ in range(N):
  a, b = map(lambda x: x-1, map(int, input().split()))
  adj[a][b] = 1
#Input:
# 5
# 1 2
# 1 3
# 1 4
# 2 4
# 3 4
#Output:
# [0, 1, 1, 1, 0]
# [0, 0, 0, 1, 0]
# [0, 0, 0, 1, 0]
# [0, 0, 0, 0, 0]
# [0, 0, 0, 0, 0]
  #여기서 만약 간선의 방향이 양방향일경우
  adj[b][a] =1 #즉 adj[a][b] = 1 = adj[b][a] 를 해준다.

# [0, 1, 1, 1, 0]
# [1, 0, 0, 1, 0]
# [1, 0, 0, 1, 0]
# [1, 1, 1, 0, 0]
# [0, 0, 0, 0, 0]

# 그럼 이와같이 만들어진다.
for row in adj:
  print(row)

# 여기까지는 맵을 만드는 과정에 가깝다.
# 이제 이 맵 안에서 
# 1. 연결요소를 찾거나
# 2. 길을 찾거나
# 3. 특정 영역의 넓이를 구하거나 하는 문제가 나온다.